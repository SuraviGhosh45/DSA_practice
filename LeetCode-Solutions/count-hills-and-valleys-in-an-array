Problem Link --> https://leetcode.com/problems/count-hills-and-valleys-in-an-array/?envType=daily-question&envId=2025-07-27

Example:
Input: nums = [2,4,1,1,6,5]
Output: 3

Explanation:
At index 0: There is no non-equal neighbor of 2 on the left, so index 0 is neither a hill nor a valley.
At index 1: The closest non-equal neighbors of 4 are 2 and 1. Since 4 > 2 and 4 > 1, index 1 is a hill. 
At index 2: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 2 is a valley.
At index 3: The closest non-equal neighbors of 1 are 4 and 6. Since 1 < 4 and 1 < 6, index 3 is a valley, but note that it is part of the same valley as index 2.
At index 4: The closest non-equal neighbors of 6 are 1 and 5. Since 6 > 1 and 6 > 5, index 4 is a hill.
At index 5: There is no non-equal neighbor of 5 on the right, so index 5 is neither a hill nor a valley. 
There are 3 hills and valleys so we return 3.

Solution:
1. to ignore consecutive duplicates and not change the landscape, so we first simplify the array by removing consecutive duplicates.
2.Iterate Through the Processed Array:
 -Start from index 1 to len(nums) - 2
 -At each index i, check:
  -If nums[i] is greater than both neighbors → it's a hill.
  -If nums[i] is smaller than both neighbors → it's a valley.
3.Increase a counter whenever a hill or valley is detected and return it

Time Complexity: O(n) {One pass to remove duplicates and one pass to count hills/valleys.}
Space Complexity: O(n) {For storing the simplified array without consecutive duplicates.}

Code:
class Solution(object):
    def countHillValley(self, n):
        nums = [n[0]]  
        
        for i in range(1, len(n)):
            if n[i] != n[i - 1]:
                nums.append(n[i])

        count = 0

        for i in range(1, len(nums) - 1):
            if nums[i - 1] < nums[i] and nums[i] > nums[i + 1]:
                count += 1  
            elif nums[i - 1] > nums[i] and nums[i] < nums[i + 1]:
                count += 1 

        return count
